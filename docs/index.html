<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Johan Hidding (after Andrej Karpathy)" />
  <title>Micrograd in Julia</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="theme.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Micrograd in Julia</h1>
<p class="subtitle">introduction to automatic differentiation and backpropagation</p>
<p class="author">Johan Hidding (after Andrej Karpathy)</p>
<!--        <div id="dark-mode-toggle">
                <p>Dark mode: <button class="dark-mode-button"
                        aria-label="Toggle dark mode"
                        onclick="toggle_dark_mode()">
                        <span></span><span></span>
                </button></p>
</div> -->
</header>
<div class="row">
        <div class="col-6 col-s-9" id="main">
<p><a href="https://entangled.github.io/"><img src="https://img.shields.io/badge/entangled-Use%20the%20source!-%2300aeff" alt="Entangled badge" /></a></p>
<p>A literate Julia translation of Andrej Karpathy’s <code>micrograd</code>, following his video lecture. I’ll include some info boxes about Julia for Pythonista’s on the way.</p>
<section id="derivatives" class="level1">
<h1>Derivatives</h1>
<p>The goal of this exercise is to compute derivatives across a neural network. The idea is that we compute a value of some very complicated function in a forward pass, and then, traversing backward through the tree, we can infer (cheaply) the gradient of the output with respect to input variables.</p>
<p>We start by learning about derivatives, usually defined as the rate of increment in a function in the limit where some step-size goes to zero:</p>
<p><span class="math display">\[\partial_x f(x) := \lim_{h \to 0} {f(x+h) - f(x) \over h}.\]</span></p>
<p>For functions of a single parameter, we may also write <span class="math inline">\(\partial_x f(x) = f&#39;(x)\)</span>, allowing us to sometimes drop the gratuitous <span class="math inline">\(x\)</span> from our notation (it’s a dummy free variable). From this definition we can compute the derivative of composite functions analytically.</p>
<section id="sum-rule" class="level2">
<h2>Sum rule</h2>
<p>Given <span class="math inline">\(f = u + v\)</span>, we may see from the linearity in the definition of the derivative that,</p>
<div class="result">
<p><span class="math display">\[(u+v)&#39; = u&#39; + v&#39;.\]</span></p>
</div>
</section>
<section id="chain-rule" class="level2">
<h2>Chain rule</h2>
<p>Now we have a function <span class="math inline">\(f = u \circ v\)</span>, meaning</p>
<p><span class="math display">\[f(x) = u(v(x)).\]</span></p>
<p>First of all, we need to see that inside the limit we can write,</p>
<p><span class="math display">\[\lim_{h \to 0} \Big[f&#39;(x) = {f(x+h) - f(x) \over h}\Big],\]</span></p>
<p>therefore,</p>
<p><span class="math display">\[\lim_{h \to 0} \Big[f(x+h) = f(x) + h f&#39;(x)\Big].\]</span></p>
<p>This also shows how the derivative approximates a function locally by a linear function. Then, writing out the definition and replacing <span class="math inline">\(v(x+h)\)</span>, we recover the definition of the derivative of <span class="math inline">\(u\)</span>, evaluated at <span class="math inline">\(y=v(x)\)</span>, if we multiply by <span class="math inline">\(v&#39;(x)\)</span> on both sides of the fraction.</p>
<p><span class="math display">\[\begin{align}f&#39;(x) &amp;= \lim_{h \to 0} {u(v(x+h)) - u(v(x)) \over h}\\
                     &amp;= \lim_{h \to 0} {u(v(x) + hv&#39;(x)) - u(v(x)) \over h}\\
                     &amp;= \lim_{h \to 0} {(u(v(x) + hv&#39;(x)) - u(v(x)))v&#39;(x) \over hv&#39;(x)}\\
                     &amp;= \lim_{h \to 0} {u(y + \tilde{h}) - u(y) \over \tilde{h}} v&#39;(x)\\
                     &amp;= u&#39;(v(x)) v&#39;(x).\end{align}\]</span></p>
<p>In short,</p>
<div class="result">
<p><span class="math display">\[(u \circ v)&#39; = (u&#39; \circ v) v&#39;\]</span></p>
</div>
<p>Wikipedia gives us another nice proof, based on a different definition of differentiation. We say a function <span class="math inline">\(f\)</span> is differentiable in <span class="math inline">\(a\)</span> if there exists a function <span class="math inline">\(q\)</span> such that</p>
<p><span class="math display">\[f(x) - f(a) = q(x)(x - a),\]</span></p>
<p>and <span class="math inline">\(f&#39;(a) = q(a)\)</span>. Then, given that <span class="math inline">\(f = u \circ v\)</span>,</p>
<p><span class="math display">\[\begin{align}u(v(x)) - u(v(a)) &amp;= q(v(x))(v(x) - v(a))\\
        &amp;= q(v(x))r(x)(x - a),\end{align}\]</span></p>
<p>Meaning that <span class="math inline">\(f&#39;(a) = q(v(a))r(a)\)</span>, where <span class="math inline">\(q(v(a)) = u&#39;(v(a))\)</span> and <span class="math inline">\(r(a) = v&#39;(a)\)</span>. Ok, with that out of the way, we can implement the first tiny version of an automatic differentating back propagation.</p>
</section>
</section>
<section id="computation" class="level1">
<h1>Computation</h1>
<p>We define the a data structure that traces a computation.</p>
<div class="named-code-block">
<p>«value»</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">mutable struct</span> Value{T}</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    value <span class="op">::</span> T</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    operator <span class="op">::</span> <span class="dt">Union</span>{<span class="dt">Symbol</span><span class="op">,</span><span class="dt">Expr</span>}</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    children <span class="op">::</span> <span class="dt">Vector</span>{Value{T}}</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    grad <span class="op">::</span> T</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    label <span class="op">::</span> <span class="dt">Union</span>{<span class="dt">String</span><span class="op">,</span> <span class="dt">Nothing</span>}</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>Value{T}(value<span class="op">::</span>T<span class="op">,</span> operator<span class="op">::</span><span class="dt">Union</span>{<span class="dt">Expr</span><span class="op">,</span><span class="dt">Symbol</span>}<span class="op">,</span> children<span class="op">::</span><span class="dt">Vector</span>{Value{T}}) <span class="kw">where</span> T <span class="op">=</span> </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    Value(value<span class="op">,</span> operator<span class="op">,</span> children<span class="op">,</span> zero(T)<span class="op">,</span> <span class="cn">nothing</span>)</span></code></pre></div>
</div>
<section id="julia-methods" class="level3 alert">
<h3>Julia methods</h3>
<p>Julia is not an object oriented language. Instead, you can define <em>methods</em> on top of any type that is already defined, similar to how you would overload functions in C++. The correct implementation of a method is selected base on the types of the arguments. The pattern of defining a <code>struct</code> and a set of methods that take that structure as a first argument replaces most of what you would do in Python using classes.</p>
<p>Addition, multiplication and similar operators are also just functions, and can be called as such. The following are identical:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="fl">1</span> <span class="op">+</span> <span class="fl">2</span> <span class="op">+</span> <span class="fl">3</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fl">6</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="op">+</span>(<span class="fl">1</span><span class="op">,</span> <span class="fl">2</span><span class="op">,</span> <span class="fl">3</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fl">6</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>julia<span class="op">&gt;</span> <span class="op">+</span>(<span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">...</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="fl">6</span></span></code></pre></div>
<p>To overload functions in the standard library, remember to specify them with their full namespace. In the case of operators, an aditional <code>:</code> is required to have unambiguous syntax.</p>
</section>
<p>Now we add methods to perform addition and multiplication on <code>Value</code>s. These implementations make sure that sum-nodes are joined into larger sum-nodes, likewise with product-nodes.</p>
<div class="named-code-block">
<p>«value»</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="op">:+</span>(a <span class="op">::</span> Value{T}<span class="op">,</span> b <span class="op">::</span> Value{T}) <span class="kw">where</span> T</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    Value{T}(a.value <span class="op">+</span> b.value<span class="op">,</span> <span class="op">:+,</span> [(a.operator <span class="op">==</span> <span class="op">:+</span> ? a.children <span class="op">:</span> a)<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                                     (b.operator <span class="op">==</span> <span class="op">:+</span> ? b.children <span class="op">:</span> b)])</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="bu">Base</span>.<span class="op">:*</span>(a <span class="op">::</span> Value{T}<span class="op">,</span> b <span class="op">::</span> Value{T}) <span class="kw">where</span> T</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    Value{T}(a.value <span class="op">*</span> b.value<span class="op">,</span> <span class="op">:*,</span> [(a.operator <span class="op">==</span> <span class="op">:*</span> ? a.children <span class="op">:</span> a)<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                                     (b.operator <span class="op">==</span> <span class="op">:*</span> ? b.children <span class="op">:</span> b)])</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<p>To create a literal value, say an input:</p>
<div class="named-code-block">
<p>«value»</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> literal(value <span class="op">::</span> T) <span class="kw">where</span> T</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    Value{T}(value<span class="op">,</span> <span class="op">:</span><span class="kw">const</span><span class="op">,</span> Value{T}[])</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<p>To add a label to a value, we’ll have a nice <code>|&gt; label("x")</code> syntax.</p>
<div class="named-code-block">
<p>«value»</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> label(l <span class="op">::</span> <span class="dt">String</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    v <span class="op">-&gt;</span> <span class="kw">begin</span> v.label <span class="op">=</span> l<span class="op">;</span> v <span class="kw">end</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<section id="composing-and-piping" class="level3 alert">
<h3>Composing and piping</h3>
<p>One pattern that we may find in object oriented languages, is that of having methods that mutate an object and then return <code>self</code> or <code>this</code>. This way we can build a structure incrementally using setter methods. In Julia a similar pattern can be expressed by passing an object through a pipeline using the <code>|&gt;</code> operator. Given the above two methods we can say</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>literal(<span class="fl">42.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;the answer&quot;</span>)</span></code></pre></div>
<p>Note the very convenient <code>x -&gt; f(x)</code> syntax for defining one-liner lambda functions. Another way to define <code>label</code> would be:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>label(l<span class="op">::</span><span class="dt">String</span>) <span class="op">=</span> <span class="kw">function</span> (v<span class="op">::</span>Value{T}) <span class="kw">where</span> T</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    v.label <span class="op">=</span> l</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    v</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
<p>Choices, choices, style and more choices.</p>
</section>
<section id="topological-sort" class="level2">
<h2>Topological sort</h2>
<p>Computing with <code>Value</code>s will generate, along with a result a dependency graph that shows exactly how we arrived at the result. We will be walking this graph up and down, which is why it is a usefull thing to have a function that iterates all nodes in <em>topological order</em>.</p>
<p>Topological order meaning: assign a number to each node, starting with the root node (being the final operation). We assign to its children a number one greater than the parent. If a child has multiple parents we should take the largest value. If we then evaluate the nodes from highest number down to the root, we are sure that at every stage all the necessary dependencies are already computed.</p>
<p>Karpathy glosses over the definition of this function. A naive implementation (like I started out with) will make the mistake of putting nodes in the wrong order. Karpathy shows a recursive algorithm. An alternative is a marking approach, where we do not add a node until all outgoing edges have been accounted for. This however, also requires us to keep track of outgoing nodes. For the moment, the recursive algorithm will do.</p>
<div class="named-code-block">
<p>«topo-sort»</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> topo_sort(node<span class="op">,</span> children <span class="op">=</span> n <span class="op">-&gt;</span> n.children<span class="op">,</span> visited <span class="op">=</span> <span class="cn">nothing</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> isnothing(visited) ? [] <span class="op">:</span> visited</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Channel</span>() <span class="kw">do</span> chan</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> node ∉ visited</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            push<span class="op">!</span>(visited<span class="op">,</span> node)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">for</span> c <span class="kw">in</span> children(node)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>                foreach(n<span class="op">-&gt;</span>put<span class="op">!</span>(chan<span class="op">,</span> n)<span class="op">,</span> topo_sort(c<span class="op">,</span> children<span class="op">,</span> visited))</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">end</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            put<span class="op">!</span>(chan<span class="op">,</span> node)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<section id="generators-and-channels" class="level3 alert">
<h3>Generators and channels</h3>
<p>In Python you can create a generate as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> natural_numbers():</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">yield</span> x</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        x <span class="op">+=</span> <span class="dv">1</span></span></code></pre></div>
<p>In Julia, the easiest way to create an generator is using <code>Channel() do</code> syntax. Under the hood this uses a very similar system of coroutines. The nice thing is that channels work very well in a multithreading environment, so your code is immediately more generic.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>natural_numbers() <span class="op">=</span> <span class="dt">Channel</span>() <span class="kw">do</span> chan</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="fl">1</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> <span class="ex">true</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        put<span class="op">!</span>(chan<span class="op">,</span> x)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        x <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</section>
</section>
<section id="special-iterator-this_and_others" class="level2">
<h2>Special iterator: <code>this_and_others</code></h2>
<p>I supposed that, from some generality concerns, we could have combinators with more than two children. In that case, we’d like to iterate over each child, together with all their siblings (excluding the child). This is why I made an iterator that does just that <code>this_and_others</code>. Given a <code>Vector{T}</code> it yields pairs of an element and a vector containing the other elements.</p>
<div class="named-code-block">
<p>«this-and-others»</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> this_and_others(v <span class="op">::</span> <span class="dt">Vector</span>{T}) <span class="kw">where</span> T</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Channel</span>() <span class="kw">do</span> chan</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (idx<span class="op">,</span> x) <span class="kw">in</span> enumerate(v)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>            put<span class="op">!</span>(chan<span class="op">,</span> (x<span class="op">,</span> [v[<span class="fl">1</span><span class="op">:</span>idx<span class="op">-</span><span class="fl">1</span>]<span class="op">;</span>v[idx<span class="op">+</span><span class="fl">1</span><span class="op">:</span><span class="kw">end</span>]]))</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
</section>
<section id="derivatives-1" class="level2">
<h2>Derivatives</h2>
<p>We previously derived the sum and product rules for differentiation. When written in this form, they become rather obvious. What was all the fuss about? (verifying that our intuitions are correct, that is …)</p>
<div class="named-code-block">
<p>«backpropagate»</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> derive(symb <span class="op">::</span> <span class="dt">Symbol</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    derivatives[symb]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> derivatives <span class="op">=</span> <span class="dt">IdDict</span>(</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">:*</span> <span class="op">=&gt;</span> (_<span class="op">,</span> others) <span class="op">-&gt;</span> reduce(<span class="op">*,</span> others)<span class="op">,</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">:+</span> <span class="op">=&gt;</span> (_<span class="op">,</span> _) <span class="op">-&gt;</span> <span class="fl">1.0</span><span class="op">,</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;&lt;</span>derivatives<span class="op">&gt;&gt;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p>Now, it is a matter of walking the evaluation tree backward. Here we find the <code>topo_sort</code> routine to be useful.</p>
<div class="named-code-block">
<p>«backpropagate»</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>this<span class="op">-</span>and<span class="op">-</span>others<span class="op">&gt;&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> backpropagate(v <span class="op">::</span> Value{T}) <span class="kw">where</span> T</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    v.grad <span class="op">=</span> one(T)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> n <span class="kw">in</span> <span class="bu">Iterators</span>.reverse(collect(topo_sort(v)))</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (c<span class="op">,</span> others) <span class="kw">in</span> this_and_others(n.children)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>            c.grad <span class="op">+=</span> n.grad <span class="op">*</span> derive(n.operator)(c.value<span class="op">,</span> map(x <span class="op">-&gt;</span> x.value<span class="op">,</span> others))</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<p>Note, that a value may be used in several subexpressions, creating a diamond dependency diagram. In such a case, we want to add all contributions from different branches. This is why we find <code>c.grad += ...</code> there.</p>
</section>
</section>
<section id="first-example" class="level1">
<h1>First example</h1>
<div class="named-code-block">
<p>file:build/example1.jl</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> MicroGrad<span class="op">:</span> literal<span class="op">,</span> label<span class="op">,</span> backpropagate</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> literal(<span class="fl">2.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;a&quot;</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> literal(<span class="fl">3.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> literal(<span class="fl">10.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;c&quot;</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> a <span class="op">*</span> b <span class="op">+</span> c <span class="op">*</span> a <span class="op">|&gt;</span> label(<span class="st">&quot;d&quot;</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>println(<span class="st">&quot;$(d.label) = $(d.value)&quot;</span>)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>backpropagate(d)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>println(<span class="st">&quot;∂_$(a.label) d = $(a.grad)&quot;</span>)</span></code></pre></div>
</div>
<pre class="output"><code>d = 26.0
∂_a d = 13.0
</code></pre>
</section>
<section id="plotting-tree-in-graphviz" class="level1">
<h1>Plotting tree in <code>graphviz</code></h1>
<p>Julia has a module for interaction with Graphviz, but it requires input in dot language, so this module won’t help us here. I’ve created another package called <code>GraphvizDotLang.jl</code>.</p>
<div class="named-code-block">
<p>«visualize»</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> visualize(v<span class="op">::</span>Value{T}) <span class="kw">where</span> T</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> digraph(<span class="op">;</span> rankdir<span class="op">=</span><span class="st">&quot;LR&quot;</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> n <span class="kw">in</span> topo_sort(v)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        objid <span class="op">=</span> repr(hash(n))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        objlabel <span class="op">=</span> (isnothing(n.label) ? <span class="st">&quot;&quot;</span> <span class="op">:</span> n.label)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        reclabel <span class="op">=</span> <span class="pp">@sprintf</span> <span class="st">&quot;{ %s | data: %0.2f | grad: %0.2f }&quot;</span>  objlabel n.value n.grad</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        g <span class="op">|&gt;</span> node(<span class="st">&quot;dat_&quot;</span> <span class="op">*</span> objid<span class="op">;</span> shape<span class="op">=</span><span class="st">&quot;record&quot;</span><span class="op">,</span> label<span class="op">=</span>reclabel)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (n.operator <span class="op">!==</span> <span class="op">:</span><span class="kw">const</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>            g <span class="op">|&gt;</span> node(<span class="st">&quot;op_&quot;</span> <span class="op">*</span> objid<span class="op">;</span> label<span class="op">=</span><span class="st">&quot;$(n.operator)&quot;</span>) <span class="op">|&gt;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>                 edge(<span class="st">&quot;op_&quot;</span> <span class="op">*</span> objid<span class="op">,</span> <span class="st">&quot;dat_$objid&quot;</span>)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> c <span class="kw">in</span> n.children</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>            childid <span class="op">=</span> repr(hash(c))</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>            g <span class="op">|&gt;</span> edge(<span class="st">&quot;dat_$childid&quot;</span><span class="op">,</span> (n.operator <span class="op">!==</span> <span class="op">:</span><span class="kw">const</span> ? <span class="st">&quot;op_&quot;</span> <span class="op">:</span> <span class="st">&quot;dat_&quot;</span>) <span class="op">*</span> objid)</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    g</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>file:build/viz-example1.jl</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>example1<span class="op">&gt;&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> MicroGrad<span class="op">:</span> visualize</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> GraphvizDotLang<span class="op">:</span> save</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>save(visualize(d)<span class="op">,</span> <span class="cn">ARGS</span>[<span class="fl">1</span>])</span></code></pre></div>
</div>
<p><img src="fig/example1.svg" class="figure" alt="" /></p>
</section>
<section id="a-neuron" class="level1">
<h1>A Neuron</h1>
<p>The neuron takes many inputs and then computes a weighted sum over those inputs, and passes the results through an activation function:</p>
<p><span class="math display">\[f(x_i) = {\rm sig} \Big[ \sum w_i x_i + b \Big].\]</span></p>
<p>In this case, the activation function is some sigmoid.</p>
<p><img src="fig/sigmoid.svg" class="figure" alt="" /></p>
<div class="named-code-block">
<p>«value»</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="bu">Base</span>.tanh(v<span class="op">::</span>Value{T}) <span class="kw">where</span> T</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    Value{T}(tanh(v.value)<span class="op">,</span> <span class="op">:</span>tanh<span class="op">,</span> [v])</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«derivatives»</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>tanh <span class="op">=&gt;</span> (value<span class="op">,</span> _) <span class="op">-&gt;</span> <span class="bu">Base</span>.<span class="bu">Math</span>.sech(value)<span class="op">^</span><span class="fl">2</span><span class="op">,</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>file:build/viz_example2.jl</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> MicroGrad<span class="op">:</span> literal<span class="op">,</span> label<span class="op">,</span> backpropagate<span class="op">,</span> visualize</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> GraphvizDotLang<span class="op">:</span> save</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> literal(<span class="fl">2.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;x1&quot;</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> literal(<span class="fl">0.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;x2&quot;</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>w1 <span class="op">=</span> literal(<span class="op">-</span><span class="fl">3.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;w1&quot;</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>w2 <span class="op">=</span> literal(<span class="fl">1.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;w2&quot;</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> literal(<span class="fl">6.8813735870195432</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> x1<span class="op">*</span>w1 <span class="op">+</span> x2<span class="op">*</span>w2 <span class="op">+</span> b <span class="op">|&gt;</span> label(<span class="st">&quot;n&quot;</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>o <span class="op">=</span> tanh(n) <span class="op">|&gt;</span> label(<span class="st">&quot;out&quot;</span>)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>backpropagate(o)</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>save(visualize(o)<span class="op">,</span> <span class="cn">ARGS</span>[<span class="fl">1</span>])</span></code></pre></div>
</div>
<p><img src="fig/example2.svg" class="figure" alt="" /></p>
</section>
<section id="more-derivatives" class="level1">
<h1>More derivatives</h1>
<p>We want more derivatives!</p>
<div class="named-code-block">
<p>«derivatives»</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>inv <span class="op">=&gt;</span> (x<span class="op">,</span> _) <span class="op">-&gt;</span> <span class="op">-</span><span class="fl">1</span><span class="op">/</span>x<span class="op">^</span><span class="fl">2</span><span class="op">,</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>log <span class="op">=&gt;</span> (x<span class="op">,</span> _) <span class="op">-&gt;</span> <span class="fl">1</span><span class="op">/</span>x<span class="op">,</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>exp <span class="op">=&gt;</span> (x<span class="op">,</span> _) <span class="op">-&gt;</span> exp(x)<span class="op">,</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>negate <span class="op">=&gt;</span> (_<span class="op">,</span> _) <span class="op">-&gt;</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span></span></code></pre></div>
</div>
<p>Now we can add more operators.</p>
<div class="named-code-block">
<p>«value»</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="bu">Base</span>.convert(<span class="op">::</span><span class="dt">Type</span>{Value{T}}<span class="op">,</span> x <span class="op">::</span> T) <span class="kw">where</span> T</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>   literal(x)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> vmap(f<span class="op">,</span> operator<span class="op">::</span><span class="dt">Symbol</span><span class="op">,</span> value<span class="op">::</span>Value{T}) <span class="kw">where</span> T</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    Value{T}(f(value.value)<span class="op">,</span> operator<span class="op">,</span> [value])</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="op">:*</span>(s<span class="op">::</span>U<span class="op">,</span> a<span class="op">::</span>Value{T}) <span class="kw">where</span> {T<span class="op">,</span> U <span class="op">&lt;:</span> <span class="dt">Number</span>} <span class="op">=</span> convert(Value{T}<span class="op">,</span> convert(T<span class="op">,</span>s)) <span class="op">*</span> a</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.inv(a<span class="op">::</span>Value{T}) <span class="kw">where</span> T <span class="op">=</span> vmap(inv<span class="op">,</span> <span class="op">:</span>inv<span class="op">,</span> a)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="op">:/</span>(a<span class="op">::</span>Value{T}<span class="op">,</span> b<span class="op">::</span>Value{T}) <span class="kw">where</span> T <span class="op">=</span> a <span class="op">*</span> inv(b)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.exp(a<span class="op">::</span>Value{T}) <span class="kw">where</span> T <span class="op">=</span> vmap(exp<span class="op">,</span> <span class="op">:</span>exp<span class="op">,</span> a)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>negate(a<span class="op">::</span>Value{T}) <span class="kw">where</span> T <span class="op">=</span> vmap(<span class="op">-,</span> <span class="op">:</span>negate<span class="op">,</span> a)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="op">:-</span>(a<span class="op">::</span>Value{T}) <span class="kw">where</span> T <span class="op">=</span> negate(a)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="op">:-</span>(a<span class="op">::</span>Value{T}<span class="op">,</span> b<span class="op">::</span>Value{T}) <span class="kw">where</span> T <span class="op">=</span> a <span class="op">+</span> negate(b)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="op">:-</span>(a<span class="op">::</span>Value{T}<span class="op">,</span> b<span class="op">::</span>U) <span class="kw">where</span> {T<span class="op">,</span> U <span class="op">&lt;:</span> <span class="dt">Number</span>} <span class="op">=</span> a <span class="op">-</span> literal(convert(T<span class="op">,</span>b))</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="op">:+</span>(a<span class="op">::</span>Value{T}<span class="op">,</span> b<span class="op">::</span>U) <span class="kw">where</span> {T<span class="op">,</span> U <span class="op">&lt;:</span> <span class="dt">Number</span>} <span class="op">=</span> a <span class="op">+</span> literal(convert(T<span class="op">,</span>b))</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="bu">Base</span>.<span class="op">:^</span>(a<span class="op">::</span>Value{T}<span class="op">,</span> b<span class="op">::</span>U) <span class="kw">where</span> {T<span class="op">,</span> U <span class="op">&lt;:</span> <span class="dt">Integer</span>} <span class="op">=</span> Value{T}(a.value<span class="op">^</span>b<span class="op">,</span> <span class="op">:</span>(x<span class="op">^$</span>(b))<span class="op">,</span> [a])</span></code></pre></div>
</div>
<p>Now we could say <span class="math inline">\(\tanh x = (\exp(2x) - 1) / (\exp(2x) + 1)\)</span></p>
<div class="named-code-block">
<p>file:build/viz_example4.jl</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> MicroGrad<span class="op">:</span> literal<span class="op">,</span> label<span class="op">,</span> backpropagate<span class="op">,</span> visualize</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> GraphvizDotLang<span class="op">:</span> save</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>mytanh(x) <span class="op">=</span> <span class="kw">begin</span> y <span class="op">=</span> exp(<span class="fl">2</span><span class="op">*</span>x)<span class="op">;</span> (y <span class="op">-</span> <span class="fl">1</span>) <span class="op">/</span> (y <span class="op">+</span> <span class="fl">1</span>) <span class="kw">end</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>x1 <span class="op">=</span> literal(<span class="fl">2.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;x1&quot;</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>x2 <span class="op">=</span> literal(<span class="fl">0.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;x2&quot;</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>w1 <span class="op">=</span> literal(<span class="op">-</span><span class="fl">3.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;w1&quot;</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>w2 <span class="op">=</span> literal(<span class="fl">1.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;w2&quot;</span>)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> literal(<span class="fl">6.8813735870195432</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;b&quot;</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> x1<span class="op">*</span>w1 <span class="op">+</span> x2<span class="op">*</span>w2 <span class="op">+</span> b <span class="op">|&gt;</span> label(<span class="st">&quot;n&quot;</span>)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>o <span class="op">=</span> mytanh(n) <span class="op">|&gt;</span> label(<span class="st">&quot;out&quot;</span>)</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>backpropagate(o)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>save(visualize(o)<span class="op">,</span> <span class="cn">ARGS</span>[<span class="fl">1</span>])</span></code></pre></div>
</div>
<p><img src="fig/example3.svg" class="figure" alt="" /></p>
<p>I also specify derivatives for the generic case of <code>x -&gt; x^n</code>.</p>
<div class="named-code-block">
<p>«backpropagate»</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> derive(expr <span class="op">::</span> <span class="dt">Expr</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">@match</span> expr <span class="kw">begin</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Expr</span>(<span class="op">:</span>call<span class="op">,</span> <span class="op">:^,</span> <span class="op">:</span>x<span class="op">,</span> n) <span class="op">=&gt;</span> (x<span class="op">,</span> _) <span class="op">-&gt;</span> n <span class="op">*</span> x<span class="op">^</span>(n<span class="op">-</span><span class="fl">1</span>)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Expr</span>(expr_type<span class="op">,</span> _<span class="op">...</span>)  <span class="op">=&gt;</span> error(<span class="st">&quot;Unknown expression $(expr) of type $(expr_type)&quot;</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
</section>
<section id="building-a-neural-net" class="level1">
<h1>Building a neural net</h1>
<section id="neuron" class="level2">
<h2>Neuron</h2>
<div class="named-code-block">
<p>«neuron»</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Neuron{T}</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">::</span> <span class="dt">Vector</span>{Value{T}}</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    bias <span class="op">::</span> Value{T}</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>Neuron{T}(n<span class="op">::</span><span class="dt">Int</span>) <span class="kw">where</span> T <span class="op">&lt;:</span> <span class="dt">Real</span> <span class="op">=</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    Neuron{T}(</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>        [literal(rand() <span class="op">*</span> <span class="fl">2</span> <span class="op">-</span> <span class="fl">1</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;w$(i)&quot;</span>) <span class="kw">for</span> i <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n]<span class="op">,</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>        literal(rand() <span class="op">*</span> <span class="fl">2</span> <span class="op">-</span> <span class="fl">1</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;bias&quot;</span>))</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> (n<span class="op">::</span>Neuron{T})(x<span class="op">::</span><span class="dt">Vector</span>{Value{T}}) <span class="kw">where</span> T <span class="op">&lt;:</span> <span class="dt">Real</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    tanh(sum(n.weights <span class="op">.*</span> x<span class="op">;</span> init <span class="op">=</span> n.bias))</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
</section>
<section id="layer" class="level2">
<h2>Layer</h2>
<div class="named-code-block">
<p>«layer»</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Layer{T}</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    neurons <span class="op">::</span> <span class="dt">Vector</span>{Neuron{T}}</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>Layer{T}(n_in<span class="op">::</span><span class="dt">Int</span><span class="op">,</span> n_out<span class="op">::</span><span class="dt">Int</span>) <span class="kw">where</span> T <span class="op">&lt;:</span> <span class="dt">Real</span> <span class="op">=</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    Layer{T}([Neuron{T}(n_in) <span class="kw">for</span> _ <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span>n_out])</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> (l<span class="op">::</span>Layer{T})(x<span class="op">::</span><span class="dt">Vector</span>{Value{T}}) <span class="kw">where</span> T <span class="op">&lt;:</span> <span class="dt">Real</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    [n(x) <span class="kw">for</span> n <span class="kw">in</span> l.neurons]</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
</section>
<section id="multi-layer-perceptron" class="level2">
<h2>Multi-layer perceptron</h2>
<div class="named-code-block">
<p>«mlp»</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MLP{T}</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    layers <span class="op">::</span> <span class="dt">Vector</span>{Layer{T}}</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>pairs(it) <span class="op">=</span> zip(it[<span class="fl">1</span><span class="op">:</span><span class="kw">end</span><span class="op">-</span><span class="fl">1</span>]<span class="op">,</span> it[<span class="fl">2</span><span class="op">:</span><span class="kw">end</span>])</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>MLP{T}(n_in<span class="op">::</span><span class="dt">Int</span><span class="op">,</span> n_out<span class="op">::</span><span class="dt">Vector</span>{<span class="dt">Int</span>}) <span class="kw">where</span> T <span class="op">&lt;:</span> <span class="dt">Real</span> <span class="op">=</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    MLP{T}([Layer{T}(s<span class="op">...</span>) <span class="kw">for</span> s <span class="kw">in</span> pairs([n_in<span class="op">;</span> n_out])])</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> (mlp<span class="op">::</span>MLP{T})(x<span class="op">::</span><span class="dt">Vector</span>{Value{T}}) <span class="kw">where</span> T <span class="op">&lt;:</span> <span class="dt">Real</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> l <span class="kw">in</span> mlp.layers</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> l(x)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    x</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> (mlp<span class="op">::</span>MLP{T})(x<span class="op">::</span><span class="dt">Vector</span>{T}) <span class="kw">where</span> T <span class="op">&lt;:</span> <span class="dt">Real</span></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>    mlp(literal.(x))</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> errsqr_loss(y_ref<span class="op">,</span> y)</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    sum((y_ref .<span class="op">-</span> y)<span class="op">.^</span><span class="fl">2</span>)</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>file:build/neural_net.jl</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> MicroGrad<span class="op">:</span> literal<span class="op">,</span> label<span class="op">,</span> backpropagate<span class="op">,</span> MLP<span class="op">,</span> visualize</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> GraphvizDotLang<span class="op">:</span> save</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> MLP{<span class="dt">Float64</span>}(<span class="fl">3</span><span class="op">,</span> [<span class="fl">4</span><span class="op">,</span> <span class="fl">4</span><span class="op">,</span> <span class="fl">1</span>])</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> f([literal(<span class="fl">1.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;in1&quot;</span>)<span class="op">,</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        literal(<span class="fl">2.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;in2&quot;</span>)<span class="op">,</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        literal(<span class="fl">4.0</span>) <span class="op">|&gt;</span> label(<span class="st">&quot;in3&quot;</span>)])[<span class="fl">1</span>] <span class="op">|&gt;</span> label(<span class="st">&quot;out&quot;</span>)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>backpropagate(y)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>save(visualize(y)<span class="op">,</span> <span class="cn">ARGS</span>[<span class="fl">1</span>])</span></code></pre></div>
</div>
<p><img src="fig/mlp.svg" class="figure" alt="" /></p>
</section>
<section id="enumerate-parameters" class="level2">
<h2>Enumerate parameters</h2>
<p>To make the model learn, we need to have access to all the parameters in the model.</p>
<div class="named-code-block">
<p>«neuron»</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> parameters(n <span class="op">::</span> Neuron{T}) <span class="kw">where</span> T</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    [n.weights<span class="op">;</span> n.bias]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«layer»</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> parameters(l <span class="op">::</span> Layer{T}) <span class="kw">where</span> T</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    vcat(parameters.(l.neurons)<span class="op">...</span>)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>«mlp»</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> parameters(mlp <span class="op">::</span> MLP{T}) <span class="kw">where</span> T</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    vcat(parameters.(mlp.layers)<span class="op">...</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
</section>
<section id="write-a-loss-function" class="level2">
<h2>Write a loss function</h2>
<div class="named-code-block">
<p>«learn»</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> stop_after_n(n)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">function</span> (i<span class="op">,</span> _<span class="op">,</span> loss)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>        i % <span class="fl">10</span> <span class="op">==</span> <span class="fl">0</span> <span class="op">&amp;&amp;</span> println(<span class="st">&quot;$(i:4) $(loss)&quot;</span>)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>        i <span class="op">&gt;=</span> n</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> learn(nn<span class="op">,</span> xs<span class="op">,</span> y_reference<span class="op">;</span> lossfunc<span class="op">=</span>errsqr_loss<span class="op">,</span> stop<span class="op">=</span>stop_after_n(<span class="fl">100</span>)<span class="op">,</span> step<span class="op">=</span><span class="fl">0.05</span>)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    ps <span class="op">=</span> parameters(nn)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    println(<span class="st">&quot;Network with $(length(ps)) free parameters.&quot;</span>)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>    prev <span class="op">=</span> <span class="cn">Inf</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">while</span> <span class="ex">true</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>        y_prediction <span class="op">=</span> [nn(literal.(x))[<span class="fl">1</span>] <span class="kw">for</span> x <span class="kw">in</span> xs]</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>        loss <span class="op">=</span> lossfunc(y_prediction<span class="op">,</span> y_reference)</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> stop(i<span class="op">,</span> prev<span class="op">,</span> loss.value)</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">break</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> loss.value</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>        backpropagate(loss)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> p <span class="kw">in</span> ps</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>            p.value <span class="op">-=</span> p.grad <span class="op">*</span> step</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>            p.grad <span class="op">=</span> <span class="fl">0</span></span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a>        i <span class="op">+=</span> <span class="fl">1</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
<div class="named-code-block">
<p>file:build/learn.jl</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> MicroGrad<span class="op">:</span> MLP<span class="op">,</span> literal<span class="op">,</span> learn</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> main()</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> MLP{<span class="dt">Float64</span>}(<span class="fl">3</span><span class="op">,</span> [<span class="fl">4</span><span class="op">,</span> <span class="fl">4</span><span class="op">,</span> <span class="fl">1</span>])</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">=</span> [ <span class="fl">2.0</span>  <span class="fl">3.0</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>           <span class="fl">3.0</span> <span class="op">-</span><span class="fl">1.0</span>  <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>           <span class="fl">0.5</span>  <span class="fl">1.0</span>  <span class="fl">1.0</span><span class="op">;</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>           <span class="fl">1.0</span>  <span class="fl">1.0</span> <span class="op">-</span><span class="fl">1.0</span> ] <span class="op">|&gt;</span> eachrow <span class="op">|&gt;</span> collect</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    ys <span class="op">=</span> literal.([ <span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="op">-</span><span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span> ])</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>    learn(f<span class="op">,</span> xs<span class="op">,</span> ys<span class="op">;</span> step<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    println([f(literal.(x))[<span class="fl">1</span>].value <span class="kw">for</span> x <span class="kw">in</span> xs])</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>main()</span></code></pre></div>
</div>
<pre class="output"><code>Network with 41 free parameters.
0:4 4.401224265066642
10:9 0.10680327204876786
20:19 0.04295424915398209
30:29 0.02649130300202249
40:39 0.01903549059850462
50:49 0.014806175731354152
60:59 0.012089874628403451
70:69 0.010201530459081717
80:79 0.008814492075746905
90:89 0.0077535471855444535
100:99 0.006916403797174819
[0.9576062369652699, -0.9440254868363128, -0.9815653016464002, 0.9594267523406128]
</code></pre>
</section>
</section>
<section id="appendix-a-micrograd-module" class="level1">
<h1>Appendix A: MicroGrad module</h1>
<div class="named-code-block">
<p>file:src/MicroGrad.jl</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode julia"><code class="sourceCode julia"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> MicroGrad</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> GraphvizDotLang<span class="op">:</span> digraph<span class="op">,</span> node<span class="op">,</span> edge<span class="op">,</span> attr</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Printf<span class="op">:</span> <span class="pp">@sprintf</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> MLStyle<span class="op">:</span> <span class="pp">@match</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>value<span class="op">&gt;&gt;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>topo<span class="op">-</span>sort<span class="op">&gt;&gt;</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>backpropagate<span class="op">&gt;&gt;</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>visualize<span class="op">&gt;&gt;</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>neuron<span class="op">&gt;&gt;</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>layer<span class="op">&gt;&gt;</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>mlp<span class="op">&gt;&gt;</span></span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>learn<span class="op">&gt;&gt;</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code></pre></div>
</div>
</section>
        </div>
         <div class="col-3 col-s-3 menu" id="menu-container">
                <div id="menu"><nav id="TOC" role="doc-toc">
                                <ul>
                                <li><a href="#derivatives">Derivatives</a>
                                <ul>
                                <li><a href="#sum-rule">Sum rule</a></li>
                                <li><a href="#chain-rule">Chain rule</a></li>
                                </ul></li>
                                <li><a href="#computation">Computation</a>
                                <ul>
                                <li><a href="#topological-sort">Topological sort</a></li>
                                <li><a href="#special-iterator-this_and_others">Special iterator: <code>this_and_others</code></a></li>
                                <li><a href="#derivatives-1">Derivatives</a></li>
                                </ul></li>
                                <li><a href="#first-example">First example</a></li>
                                <li><a href="#plotting-tree-in-graphviz">Plotting tree in <code>graphviz</code></a></li>
                                <li><a href="#a-neuron">A Neuron</a></li>
                                <li><a href="#more-derivatives">More derivatives</a></li>
                                <li><a href="#building-a-neural-net">Building a neural net</a>
                                <ul>
                                <li><a href="#neuron">Neuron</a></li>
                                <li><a href="#layer">Layer</a></li>
                                <li><a href="#multi-layer-perceptron">Multi-layer perceptron</a></li>
                                <li><a href="#enumerate-parameters">Enumerate parameters</a></li>
                                <li><a href="#write-a-loss-function">Write a loss function</a></li>
                                </ul></li>
                                <li><a href="#appendix-a-micrograd-module">Appendix A: MicroGrad module</a></li>
                                </ul>
                </nav></div>
        </div> 
</div>
<div class="footer">
</div>
<!-- <script>
function toggle_dark_mode() {
    var app = document.getElementsByTagName("BODY")[0];
    if (localStorage.darkMode == "dark") {
	localStorage.darkMode = "light";
	app.setAttribute("dark-mode", "light");
    } else {
	localStorage.darkMode = "dark";
	app.setAttribute("dark-mode", "dark");
    }
}
</script> -->
</body>
</html>
